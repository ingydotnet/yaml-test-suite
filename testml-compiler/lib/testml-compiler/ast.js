// Generated by CoffeeScript 2.3.1
(function() {
  require('pegex').require('tree');

  TestMLCompiler.AST = class AST extends Pegex.Tree {
    constructor(args = {}) {
      super();
      this.code = [];
      this.data = [];
      this.point = {};
      this.transforms = {};
      ({file: this.file, importer: this.importer} = args);
    }

    final() {
      var ast, got, i, imports, j, k, len, len1, len2, ref, ref1, s, statement;
      got = {
        testml: '0.3.0',
        code: [],
        data: []
      };
      ref = this.code;
      for (i = 0, len = ref.length; i < len; i++) {
        statement = ref[i];
        if (_.isPlainObject(statement)) {
          if (imports = statement.imports) {
            for (j = 0, len1 = imports.length; j < len1; j++) {
              ast = imports[j];
              if (ast.code.length && got.data.length) {
                die("Can't import code after data started");
              }
              got.code.push(...ast.code);
              got.data.push(...ast.data);
            }
          }
        } else {
          if (statement[0] === '<>') {
            statement[0] = '%<>';
          } else if (statement[0] === '=>') {
            ref1 = statement[2];
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              s = ref1[k];
              if (s[0] === '<>') {
                statement = ['%<>', [], statement];
                break;
              }
            }
          }
          got.code.push(statement);
        }
      }
      got.data.push(...(this.make_data(this.data)));
      return got;
    }

    got_code_section(got) {
      this.code = got;
    }

    got_import_directive(got) {
      var i, imports, j, len, len1, more, name, names;
      [[name, more]] = got;
      names = [name];
      for (i = 0, len = more.length; i < len; i++) {
        name = more[i];
        if (name[0] != null) {
          names.push(name[0]);
        }
      }
      imports = [];
      for (j = 0, len1 = names.length; j < len1; j++) {
        name = names[j];
        imports.push(this.importer(name, this.file));
      }
      return {
        imports: imports
      };
    }

    got_assignment_statement(got) {
      var expression, operator, variable;
      [[variable, operator], expression] = got;
      return [operator, variable, expression];
    }

    got_loop_statement(got) {
      var expr, pick;
      expr = got[0];
      pick = expr.pick || {};
      return ['%<>', _.keys(pick), expr];
    }

    got_pick_statement([pick, statement]) {
      return ['<>', pick, statement];
    }

    got_expression_statement(got) {
      var label, left, pick, right, statement, suffix_label;
      if (_.isPlainObject(got[0])) {
        label = got.shift();
      }
      pick = {};
      [left, right, suffix_label] = got;
      if (!suffix_label && _.isPlainObject(right)) {
        suffix_label = right;
        right = null;
      }
      if (right != null) {
        right[1] = left;
        statement = right;
        _.merge(pick, statement[1].pick, statement[2].pick);
      } else {
        statement = left;
      }
      if (label != null) {
        statement.push(label.label);
      } else if (suffix_label != null) {
        statement.push(suffix_label.label);
      }
      pick = _.keys(pick);
      if (pick.length > 0) {
        statement = ['<>', pick, statement];
      }
      return statement;
    }

    got_expression_label(got) {
      return {
        label: got
      };
    }

    got_suffix_label(got) {
      return {
        label: got
      };
    }

    got_pick_expression(got) {
      var i, item, len, more, pick;
      got = got[0];
      pick = {
        [`${got.shift()}`]: true
      };
      more = got[0];
      for (i = 0, len = more.length; i < len; i++) {
        item = more[i];
        if (!item.length) {
          continue;
        }
        pick[item[0]] = true;
      }
      return _.keys(pick);
    }

    got_code_expression(got) {
      var calls, e, each, expr, i, len, object, pick;
      [object, calls, each] = got;
      expr = [object, ...calls];
      pick = {};
      for (i = 0, len = expr.length; i < len; i++) {
        e = expr[i];
        _.merge(pick, e.pick || {});
      }
      if (expr.length === 1) {
        expr = expr[0];
        if (object.callable) {
          expr = ['&', expr];
        }
      } else {
        expr = ['.', ...expr];
      }
      if (each != null) {
        expr = ['%', expr, each];
      }
      if (_.isArray(expr)) {
        expr.pick = pick;
      }
      return expr;
    }

    got_point_object(got) {
      var i, index, indices, len, name, object, opcode;
      [name, indices] = got;
      object = ['*', name];
      indices || (indices = []);
      for (i = 0, len = indices.length; i < len; i++) {
        [opcode, index] = indices[i];
        object = [opcode, object, index];
      }
      object.pick = {
        [`*${name}`]: true
      };
      return object;
    }

    got_double_string(got) {
      var value;
      value = got.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
      if (value.match(/^(?:\\\\|[^\\])*?\{/)) {
        value = ["$''", value];
      }
      return value;
    }

    got_number_object(got) {
      return Number(got);
    }

    got_regex_object(got) {
      return ['/', got];
    }

    got_list_object([got]) {
      var first, i, item, len, list, rest;
      list = [];
      [first, rest] = got;
      rest = _.filter(_.map(rest, function(x) {
        return x[0];
      }));
      if (first != null) {
        list.push(first);
        for (i = 0, len = rest.length; i < len; i++) {
          item = rest[i];
          list.push(item);
        }
      }
      return [list];
    }

    got_function_object(got) {
      var i, item, len, signature;
      signature = got.length === 2 ? got.shift()[0] : [];
      got.unshift('=>', signature);
      got.pick = {};
      for (i = 0, len = signature.length; i < len; i++) {
        item = signature[i];
        if (item.match(/^\*/)) {
          got.pick[item] = true;
        }
      }
      return got;
    }

    got_callable_function_object(got) {
      return this.got_function_object(got);
    }

    got_function_variables(got) {
      var i, item, len, more, vars;
      vars = [got.shift()];
      if (!got.length) {
        return [];
      }
      more = got[0];
      for (i = 0, len = more.length; i < len; i++) {
        item = more[i];
        if (!item.length) {
          continue;
        }
        vars.push(item[0]);
      }
      return vars;
    }

    got_call_object(got) {
      var a, args, callable, i, index, indices, j, len, len1, name, object, opcode;
      [name, args, indices] = got;
      if (args != null ? args.indices : void 0) {
        indices = args;
        args = null;
      }
      callable = (args != null) && args.length === 0;
      args || (args = []);
      indices || (indices = []);
      object = [name, ...args];
      for (i = 0, len = indices.length; i < len; i++) {
        [opcode, index] = indices[i];
        object = [opcode, object, index];
      }
      object.pick = {};
      for (j = 0, len1 = args.length; j < len1; j++) {
        a = args[j];
        _.merge(object.pick, a.pick || {});
      }
      object.callable = callable;
      return object;
    }

    got_lookup_indices(got) {
      var indices;
      indices = _.map(got, (index) => {
        var m, opcode;
        opcode = ':';
        index = (function() {
          switch (false) {
            case !(m = index.match(/^"(.*)"$/)):
              return ["$''", m[1]];
            case !(m = index.match(/^'(.*)'$/)):
              return m[1];
            case !(m = index.match(/^\((.*)\)$/)):
              return [m[1]];
            case !(m = index.match(/^\[(.*)\]$/)):
              opcode = '[]';
              return [m[1]];
            case !(m = index.match(/^-?\d/)):
              opcode = '[]';
              return Number(index);
            default:
              return index;
          }
        })();
        return [opcode, index];
      });
      indices.indices = true;
      return indices;
    }

    got_lookup_index(got) {
      return got[0];
    }

    got_call_arguments(got) {
      var args, i, item, len, more;
      got = got[0];
      args = [got.shift()];
      if (!got.length) {
        return [];
      }
      more = got[0];
      for (i = 0, len = more.length; i < len; i++) {
        item = more[i];
        if (!item.length) {
          continue;
        }
        args.push(item[0]);
      }
      return args;
    }

    got_assertion_expression(got) {
      var expression, operator;
      [operator, expression] = got;
      return [operator, null, expression];
    }

    got_block_definition([label, user, points]) {
      var block, from, has_transforms, i, inherit, len, name, p, point, transforms, value;
      point = {};
      for (i = 0, len = points.length; i < len; i++) {
        p = points[i];
        [inherit, name, from, has_transforms, transforms, value] = p;
        if (name.match(/^(?:HEAD|LAST|ONLY|SKIP|TODO|DIFF)$/)) {
          point[name] = true;
        } else {
          point[name] = this.make_point(name, value, inherit, from, has_transforms, transforms);
        }
      }
      this.data || (this.data = []);
      block = {
        label: label,
        point: point
      };
      if (user.match(/\S/)) {
        block.user = user;
      }
      return this.data.push(block);
    }

    got_point_single(got) {
      var m, value;
      value = got[5];
      if (value.match(/^-?\d+(\.\d+)?$/)) {
        value = Number(value);
      } else if (m = value.match(/^'(.*)'\s*$/)) {
        value = m[1];
      } else if (m = value.match(/^"(.*)"\s*$/)) {
        value = m[1];
      }
      got[5] = value;
      return got;
    }

    got_comment_lines(got) {}

    //------------------------------------------------------------------------------
    make_point(name, value, inherit, from, has_transforms, transform_expr) {
      var CoffeeScript, flag, key, transforms;
      if (!_.isString(value)) {
        return value;
      }
      if (from && !inherit) {
        throw `Can't use '--- ${name}=${from}' without '^' in front`;
      }
      if (inherit) {
        key = from || name;
        value = this.point[key] || '';
        if (!has_transforms) {
          transform_expr = this.transforms[key] || '';
        }
      } else {
        this.point[name] = value;
      }
      transforms = {};
      _.map(_.split(transform_expr, ''), function(f) {
        return transforms[f] = true;
      });
      this.transforms[name] = inherit ? '' : transform_expr;
      if (_.isString(value)) {
        if (!transforms['#']) {
          value = value.replace(/^#.*\n/gm, '');
        }
        value = value.replace(/^\\/gm, '');
        if (!transforms['+'] && value.match(/\n/)) {
          value = value.replace(/\n+$/, '\n');
          if (value === '\n') {
            value = '';
          }
        }
        if (transforms['<']) {
          value = value.replace(/^    /gm, '');
        }
        if (transforms['~']) {
          value = value.replace(/\n+/g, '\n');
        }
        if (transforms['@']) {
          if (value.match(/\n/)) {
            value = value.replace(/\n$/, '').split(/\n/);
          } else {
            value = value.split(/\s+/);
          }
          value = [value];
        } else if (transforms['%']) {
          if (TestMLCompiler.browser) {
            CoffeeScript = window.CoffeeScript;
          } else {
            CoffeeScript = require('coffeescript');
          }
          value = eval(CoffeeScript.compile(value, {
            bare: true
          }));
          if (_.isPlainObject(value) || _.isArray(value)) {
            value = [value];
          }
        } else if (transforms['-']) {
          value = value.replace(/\n$/, '');
        }
      }
      if (transforms['/']) {
        if (_.isArray(value) && _.isArray(value[0])) {
          value = _.map(value[0], function(regex) {
            return ['/', regex];
          });
          value = [value];
        } else {
          flag = value.match(/\n/) ? 'x' : '';
          value = ['/', value.replace(/\n$/, '')];
          if (flag) {
            value.push(flag);
          }
        }
      }
      if (inherit && from) {
        this.point[name] = value;
      }
      return value;
    }

    make_data(data) {
      var block, blocks, i, len;
      blocks = [];
      for (i = 0, len = data.length; i < len; i++) {
        block = data[i];
        if (block.point.SKIP) {
          continue;
        }
        if (block.point.ONLY) {
          return [block];
        }
        if (block.point.HEAD) {
          blocks = [];
        }
        if (block.point.LAST) {
          blocks.push(block);
          return blocks;
        }
        blocks.push(block);
      }
      return blocks;
    }

  };

  // vim: ft=coffee sw=2:

}).call(this);
