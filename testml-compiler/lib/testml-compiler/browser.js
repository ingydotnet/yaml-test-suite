// Generated by CoffeeScript 2.3.1
(function() {
  var _exports, _global, _require;

  _global = window.global;

  window.global = window;

  _require = window.require;

  window.require = function() {
    return {
      require: function() {}
    };
  };

  _exports = window.exports;

  window.exports = {};

  
// Generated by CoffeeScript 2.3.1
(function() {
  /*
  name:      Pegex
  abstract:  Acmeist PEG Parsing Framework
  author:    Ingy d√∂t Net <ingy@ingy.net>
  license:   MIT
  copyright: 2010-2018
  */
  global.Pegex = (function() {
    class Pegex {};

    Pegex.prototype.version = '0.1.7';

    return Pegex;

  }).call(this);

  exports.pegex = function(grammar, receiver) {
    if (grammar == null) {
      throw "Argument 'grammar' required in function 'pegex'";
    }
    if (typeof grammar === 'string' || grammar instanceof Pegex.Input) {
      require('../pegex/grammar');
      grammar = new Pegex.Grammar({
        text: grammar
      });
    }
    if (receiver == null) {
      require('../pegex/tree/wrap');
      receiver = new Pegex.Tree.Wrap;
    } else if (typeof receiver === String) {
      receiver = require(receiver);
      receiver = new receiver;
    }
    require('../pegex/parser');
    return new Pegex.Parser({
      grammar: grammar,
      receiver: receiver
    });
  };

  exports.require = function(name) {
    return require(require('path').join(__dirname, name));
  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex');

  Pegex.Grammar = class Grammar {
    constructor(_ = {}) {
      ({file: this.file, text: this.text, tree: this.tree} = _);
      this.make_tree;
      this;
    }

    make_tree() {
      var compiler;
      if (this.tree != null) {
        return this.tree;
      }
      if (this.text == null) {
        if (this.file != null) {
          require('fs');
          this.text = fs.readFileSync(this.file).toString();
        } else {
          throw "Can't create a grammar. No tree or text or file.";
        }
      }
      require('../pegex/compiler');
      compiler = new Pegex.Compiler;
      return this.tree = compiler.compile(this.text).tree;
    }

  };

  // TODO later
// compile_into_module: (module)->

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex');

  Pegex.Receiver = class Receiver {
    constructor(a = {}) {
      ({wrap: this.wrap} = a);
      if (this.wrap == null) {
        this.wrap = false;
      }
    }

    flatten(array, times) {
      var elem, i, len, result;
      if (times == null) {
        times = -1;
      }
      if (!times--) {
        return array;
      }
      result = [];
      for (i = 0, len = array.length; i < len; i++) {
        elem = array[i];
        if (elem instanceof Array) {
          result = result.concat(this.flatten(elem, times));
        } else {
          result.push(elem);
        }
      }
      return result;
    }

  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex/receiver');

  Pegex.Tree = class Tree extends Pegex.Receiver {
    gotrule(got) {
      if (got === void 0) {
        return;
      }
      if (this.parser.parent['-wrap']) {
        return {
          [`${this.parser.rule}`]: got
        };
      }
      return got;
    }

    final(got) {
      if (got !== void 0) {
        return got;
      }
      return [];
    }

  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex');

  Pegex.Input = class Input {
    constructor(a = {}) {
      ({string: this.string} = a);
      ({file: this.file} = a);
      ({handle: this.handle} = a);
      this._buffer = '';
      this._is_eof = false;
      this._is_open = false;
      this._is_close = false;
    }

    read() {
      var buffer;
      if (!this._is_open) {
        throw "Attempted Pegex.Input.read before open";
      }
      if (this._is_eof) {
        throw "Attempted Pegex.Input.read after EOF";
      }
      buffer = this._buffer;
      this._buffer = null;
      this._is_eof = true;
      return buffer;
    }

    open() {
      if (this._is_open || this._is_close) {
        throw "Attempted to reopen Pegex.Input object";
      }
      if (this.string != null) {
        this._buffer = this.string;
      } else {
        throw "Pegex.Input.open failed. No source to open.";
      }
      this._is_open = true;
      return this;
    }

    close() {
      if (this._is_close) {
        throw "Attempted to close an unopen Pegex.Input object";
      }
      this._is_open = false;
      this._is_close = true;
      this._buffer = null;
      return this;
    }

  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  Pegex.Optimizer = class Optimizer {
    constructor({
        parser: parser1,
        grammar,
        receiver
      }) {
      this.parser = parser1;
      this.grammar = grammar;
      this.receiver = receiver;
      (this.parser != null) || (function() {
        throw "Missing attribute 'parser' for Pegex.Optimizer";
      })();
      (this.grammar != null) || (function() {
        throw "Missing attribute 'grammar' for Pegex.Optimizer";
      })();
      (this.receiver != null) || (function() {
        throw "Missing attribute 'receiver' for Pegex.Optimizer";
      })();
    }

    optimize_grammar(start) {
      var extra, key, name, node, tree, val;
      tree = this.grammar.tree;
      if (tree['+optimized']) {
        return;
      }
      if (this.parser.maxparse != null) {
        this.set_max_parse;
      }
      this.extra = {};
      for (name in tree) {
        node = tree[name];
        if (typeof node === 'string') {
          continue;
        }
        this.optimize_node(node);
      }
      this.optimize_node({
        '.ref': start
      });
      extra = delete this.extra;
      for (key in extra) {
        val = extra[key];
        tree[key] = val;
      }
      return tree['+optimized'] = 1;
    }

    optimize_node(node) {
      var action, gotrule, i, j, kind, len, len1, max, method, min, n, ref, ref1, ref2, results, rule;
      min = node['+min'];
      max = node['+max'];
      if (node['+min'] == null) {
        node['+min'] = max != null ? 0 : 1;
      }
      if (node['+max'] == null) {
        node['+max'] = min != null ? 0 : 1;
      }
      if (node['+asr'] == null) {
        node['+asr'] = 0;
      }
      ref1 = ['ref', 'rgx', 'all', 'any', 'err', 'code', 'xxx'];
      for (i = 0, len = ref1.length; i < len; i++) {
        kind = ref1[i];
        if (kind === 'xxx') {
          return;
        }
        if (node.rule = node[`.${kind}`]) {
          delete node[`.${kind}`];
          node.kind = kind;
          if (kind === 'ref') {
            rule = node.rule || (function() {
              throw "";
            })();
            if ((method = this.grammar[`rule_${rule}`]) != null) {
              node.method = this.make_method_wrapper(method);
            } else if (this.grammar.tree[rule] == null) {
              if (method = this.grammar[rule] != null) {
                console.warn(`Warning:\n\n  You have a method called '${rule}' in your grammar.\n  It should probably be called 'rule_${rule}'.\n`);
              }
              throw `No rule '${rule}' defined in grammar`;
            }
          }
          if (node.method == null) {
            node.method = this.parser[`match_${kind}`] || (function() {
              throw "";
            })();
          }
          break;
        }
      }
      if (node.kind.match(/^(?:all|any)$/)) {
        ref2 = node.rule;
        results = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          n = ref2[j];
          results.push(this.optimize_node(n));
        }
        return results;
      } else if (node.kind === 'ref') {
        ref = node.rule;
        rule = this.grammar.tree[ref];
        rule || (rule = this.extra[ref] = {});
        if (action = this.receiver[`got_${ref}`]) {
          rule.action = action;
        } else if (gotrule = this.receiver.gotrule) {
          rule.action = gotrule;
        }
        if (this.parser.debug) {
          return node.method = this.make_trace_wrapper(node.method);
        }
      } else if (node.kind === 'rgx') {
        // TODO Add ^ and compile re here
        return 0;
      }
    }

    // xxx node
    make_method_wrapper(method) {
      return function(ref, parent) {
        var parser;
        parser = this;
        parser.rule = ref;
        parser.parent = parent;
        return method.call(parser.grammar, parser, parser.buffer, parser.position);
      };
    }

    make_trace_wrapper(method) {
      return function(ref, parent) {
        var asr, note, result;
        asr = parent['+asr'];
        note = asr === -1 ? '(!)' : asr === 1 ? '(=)' : '';
        this.trace(`try_${ref}${note}`);
        if (result = method.call(this, ref, parent)) {
          this.trace(`got_${ref}${note}`);
        } else {
          this.trace(`not_${ref}${note}`);
        }
        return result;
      };
    }

    set_max_parse() {
      var counter, maxparse, method;
      require('../pegex/parser');
      maxparse = this.parser.maxparse;
      method = Pegex.Parser.match_ref;
      counter = 0;
      return Pegex.Parser.match_ref = function(...args) {
        if (counter++ >= maxparse) {
          throw `Maximum parsing rules reached (${maxparse})\n`;
        }
        return method.apply(this, ...args);
      };
    }

  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  require('../pegex/input');

  require('../pegex/optimizer');

  Pegex.Parser = class Parser {
    constructor({grammar, receiver, debug}) {
      var ref1;
      this.grammar = grammar;
      this.receiver = receiver;
      this.debug = debug;
      (this.grammar != null) || (function() {
        throw "Pegex.Parser object requires a grammar attribute";
      })();
      this.input = null;
      if (this.debug == null) {
        this.debug = (ref1 = (typeof process !== "undefined" && process !== null ? process.env.PEGEX_DEBUG : void 0) || Pegex.Parser.Debug) != null ? ref1 : false;
      }
      if (this.throw_on_error == null) {
        this.throw_on_error = true;
      }
    }

    // @debug=on
    parse(input, start) {
      var base, match, optimizer, start_rule_ref;
      if (start) {
        start = start.replace(/-/g, '_');
      }
      this.position = 0;
      this.farthest = 0;
      this.input = typeof input === 'string' ? new Pegex.Input({
        string: input
      }) : input;
      if (!this.input._is_open) {
        this.input.open();
      }
      this.buffer = this.input.read();
      if (!this.grammar) {
        throw "No 'grammar'. Can't parse";
      }
      (base = this.grammar).tree || (base.tree = this.grammar.make_tree());
      start_rule_ref = start || (this.grammar.tree['+toprule'] != null) && this.grammar.tree['+toprule'] || this.grammar.tree.TOP && 'TOP' || (function() {
        throw "No starting rule for Pegex.Parser.parse";
      })();
      if (this.receiver == null) {
        throw "No 'receiver'. Can't parse";
      }
      optimizer = new Pegex.Optimizer({
        parser: this,
        grammar: this.grammar,
        receiver: this.receiver
      });
      optimizer.optimize_grammar(start_rule_ref);
      // Add circular ref.
      this.receiver.parser = this;
      if (this.receiver.initial != null) {
        this.rule = start_rule_ref;
        this.parent = {};
        this.receiver.initial();
      }
      // TODO Make start_method in optimizer?
      if (this.debug) {
        match = optimizer.make_trace_wrapper(this.match_ref).call(this, start_rule_ref, {
          '+asr': false
        });
      } else {
        match = this.match_ref(start_rule_ref, {});
      }
      this.input.close();
      if (!match || this.position < this.buffer.length) {
        this.throw_error("Parse document failed for some reason");
        return;
      }
      if (this.receiver.final) {
        this.rule = start_rule_ref;
        this.parent = {};
        match = [this.receiver.final(...match)];
      }
      return match[0];
    }

    match_next(next) {
      var _match, assertion, count, i, kind, len1, m, match, max, method, min, position, result, return_, rule;
      // XXX say "match_next #{next}"
      ({rule, method, kind} = next);
      min = next['+min'];
      max = next['+max'];
      assertion = next['+asr'];
      position = this.position;
      match = [];
      count = 0;
      while (return_ = method.call(this, rule, next)) {
        if (!assertion) {
          position = this.position;
        }
        count++;
        match.push(...return_);
        if (max === 1) {
          break;
        }
      }
      if (!count && min === 0 && kind === 'all') {
        match = [[]];
      }
      if (max !== 1) {
        if (next['-flat']) {
          _match = [];
          for (i = 0, len1 = match.length; i < len1; i++) {
            m = match[i];
            if (m instanceof Array) {
              _match.push(...m);
            } else {
              _match.push(m);
            }
          }
          match = _match;
        } else {
          match = [match];
        }
      }
      result = count >= min && (!max || count <= max);
      result ^= assertion === -1;
      if (!result || assertion) {
        if ((this.position = position) > this.farthest) {
          this.farthest = position;
        }
      }
      if (!result) {
        return 0;
      }
      if (next['-skip']) {
        return [];
      } else {
        return match;
      }
    }

    match_rule(position, match = []) {
      var parent, ref, ret, rule;
      if ((this.position = position) > this.farthest) {
        this.farthest = position;
      }
      if (match.length > 1) {
        match = [match];
      }
      ({ref, parent} = this);
      rule = this.grammar.tree[ref] || (function() {
        throw `No rule defined for '${ref}'`;
      })();
      ret = rule.action.call(this.receiver, ...match);
      if (ret === void 0) {
        return [];
      } else {
        return [ret];
      }
    }

    match_ref(ref, parent) {
      var match, ret, rule;
      // XXX say "match_ref #{ref}"
      this.ref1 = ref;
      rule = this.grammar.tree[ref] || (function() {
        throw `No rule defined for '${ref}'`;
      })();
      match = this.match_next(rule);
      if (!match) {
        return;
      }
      if (rule.action == null) {
        return [];
      }
      this.rule = ref;
      this.parent = parent;
      ret = rule.action.call(this.receiver, ...match);
      if (ret === void 0) {
        return [];
      } else {
        return [ret];
      }
    }

    match_rgx(regexp) {
      var captures, i, m, num, re, ref1;
      // XXX say "match_rgx #{@ref1} #{regexp} '#{@buffer.substr(@position)}'"
      re = new RegExp(`^${regexp}`, 'g');
      m = re.exec(this.buffer.substr(this.position));
      if (m == null) {
        return;
      }
      this.position += re.lastIndex;
      if (this.position > this.farthest) {
        this.farthest = this.position;
      }
      captures = [];
      for (num = i = 1, ref1 = m.length; (1 <= ref1 ? i < ref1 : i > ref1); num = 1 <= ref1 ? ++i : --i) {
        captures.push(m[num] || '');
      }
      if (m.length > 2) {
        captures = [captures];
      }
      return captures;
    }

    match_all(list) {
      var elem, i, len, len1, match, position, set;
      position = this.position;
      set = [];
      len = 0;
      for (i = 0, len1 = list.length; i < len1; i++) {
        elem = list[i];
        if (match = this.match_next(elem)) {
          if (!(elem['+asr'] || elem['-skip'])) {
            set.push(...match);
            len++;
          }
        } else {
          if ((this.position = position) > this.farthest) {
            this.farthest = position;
          }
          return;
        }
      }
      if (len > 1) {
        set = [set];
      }
      return set;
    }

    match_any(list) {
      var elem, i, len1, match;
      for (i = 0, len1 = list.length; i < len1; i++) {
        elem = list[i];
        if (match = this.match_next(elem)) {
          return match;
        }
      }
      return null;
    }

    match_err(error) {
      return this.throw_error(error);
    }

    match_code(code) {
      var method;
      method = `match_rule_${code}`;
      return method.call(this);
    }

    trace(action) {
      var i, i1, i2, indent, j, ref1, ref2, snippet, x;
      indent = action.match(/^try_/);
      this.indent || (this.indent = 1);
      if (!indent) {
        this.indent--;
      }
      i1 = i2 = '';
      for (x = i = 0, ref1 = this.indent; (0 <= ref1 ? i <= ref1 : i >= ref1); x = 0 <= ref1 ? ++i : --i) {
        i1 += ' ';
      }
      for (x = j = 1, ref2 = 30 - action.length; (1 <= ref2 ? j <= ref2 : j >= ref2); x = 1 <= ref2 ? ++j : --j) {
        i2 += ' ';
      }
      if (indent) {
        this.indent++;
      }
      snippet = this.buffer.substr(this.position);
      if (snippet.length > 30) {
        snippet = snippet.substr(0, 30);
      }
      snippet = snippet.replace(/\n/g, '\\n');
      return console.warn(`${i1} ${action}${i2}>${snippet}<`);
    }

    throw_error(msg) {
      this.format_error(msg);
      if (!this.throw_on_error) {
        return 0;
      }
      throw this.error;
    }

    format_error(msg) {
      var column, context, line, lines, position;
      position = this.farthest;
      lines = (this.buffer.substr(0, position)).match(/\n/g);
      line = lines != null ? lines.length + 1 : 1;
      column = position - this.buffer.lastIndexOf("\n", position);
      context = this.buffer.substr(position, 50);
      context = context.replace(/\n/g, '\\n');
      return this.error = `Error parsing Pegex document:\n  msg: ${msg}\n  line: ${line}\n  column: ${column}\n  context: ${context}\n  position: ${position}`;
    }

  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  global.TestMLCompiler = (function() {
    class TestMLCompiler {};

    TestMLCompiler.VERSION = '0.1.4';

    TestMLCompiler.env = (global.process || {}).env || {};

    return TestMLCompiler;

  }).call(this);

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  var slice = [].slice;

  require('pegex').require('grammar');

  TestMLCompiler.DevGrammar = class DevGrammar extends Pegex.Grammar {
    constructor() {
      super();
      this.file = '../pegex/testml.pgx';
    }

  };

  TestMLCompiler.Grammar = class Grammar extends Pegex.Grammar {
    constructor() {
      super();
      this.indents = [''];
    }

    rule_indent(parser, input, offset) {
      var indent, m, ref, regex;
      ref = this.indents, [indent] = slice.call(ref, -1);
      regex = `(?=(${indent}\\ +)\\S)`;
      if (!(m = parser.match_rgx(regex))) {
        return;
      }
      this.indents.push(m[0]);
      return [];
    }

    rule_ondent(parser, input, offset) {
      var indent, ref, regex;
      parser.match_ref('comment_lines');
      ref = this.indents, [indent] = slice.call(ref, -1);
      regex = `${indent}(?=\\S)`;
      return parser.match_rgx(regex);
    }

    rule_undent(parser, input, offset) {
      var i, j, ref, regex;
      parser.match_ref('comment_lines');
      if (input.slice(offset) === '') {
        return [];
      }
      for (i = j = ref = this.indents.length - 1; (ref <= -1 ? j < -1 : j > -1); i = ref <= -1 ? ++j : --j) {
        regex = `(?=${this.indents[i]}\\S|$)`;
        if (parser.match_rgx(regex)) {
          this.indents.pop();
          return [];
        }
      }
    }

    make_tree() {
      return {
        "+toprule": "testml_document",
        "testml_document": {
          ".all": [
            {
              ".ref": "head_section"
            },
            {
              ".ref": "code_section"
            },
            {
              ".ref": "data_section"
            }
          ]
        },
        "head_section": {
          ".all": [
            {
              ".ref": "comment_lines",
              "+min": 0
            },
            {
              ".ref": "testml_directive",
              "+max": 1
            },
            {
              ".ref": "head_statement",
              "+min": 0
            }
          ]
        },
        "comment_lines": {
          ".rgx": "(?:(?:\\#.*\\r?\\n)|(\\s*\\r?\\n|\\s+$))+"
        },
        "testml_directive": {
          ".rgx": "%TestML[\\ \\t]+([0-9]+\\.[0-9]+\\.[0-9]+)(?:;(?: (?=\\S))?|\\r?\\n?)"
        },
        "head_statement": {
          ".any": [
            {
              ".ref": "head_directive"
            },
            {
              ".ref": "comment_lines"
            }
          ]
        },
        "head_directive": {
          ".ref": "xxx"
        },
        "xxx": {
          ".rgx": "XXX"
        },
        "code_section": {
          ".ref": "code_statement",
          "+min": 0
        },
        "code_statement": {
          ".any": [
            {
              ".ref": "import_directive"
            },
            {
              ".ref": "comment_lines"
            },
            {
              ".ref": "assignment_statement"
            },
            {
              ".ref": "loop_statement"
            },
            {
              ".ref": "pick_statement"
            },
            {
              ".ref": "function_statement"
            },
            {
              ".ref": "expression_statement"
            }
          ]
        },
        "import_directive": {
          ".all": [
            {
              ".rgx": "%Import"
            },
            {
              ".ref": "__"
            },
            {
              ".all": [
                {
                  ".ref": "module_name"
                },
                {
                  ".all": [
                    {
                      ".ref": "__"
                    },
                    {
                      ".ref": "module_name"
                    }
                  ],
                  "+min": 0
                }
              ]
            },
            {
              ".ref": "ending"
            }
          ]
        },
        "__": {
          ".rgx": "[\\ \\t]+"
        },
        "module_name": {
          ".rgx": "(\\S+)"
        },
        "ending": {
          ".rgx": "(?:;(?: (?=\\S))?|\\r?\\n?)"
        },
        "assignment_statement": {
          ".all": [
            {
              ".rgx": "([a-zA-Z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*)[\\ \\t]+((?:=|\\|\\|=))[\\ \\t]+"
            },
            {
              ".ref": "code_expression"
            },
            {
              ".ref": "ending"
            }
          ]
        },
        "code_expression": {
          ".all": [
            {
              ".ref": "code_object"
            },
            {
              ".ref": "function_call",
              "+min": 0
            },
            {
              ".ref": "each_call",
              "+max": 1
            }
          ]
        },
        "code_object": {
          ".any": [
            {
              ".ref": "point_object"
            },
            {
              ".ref": "string_object"
            },
            {
              ".ref": "number_object"
            },
            {
              ".ref": "regex_object"
            },
            {
              ".ref": "list_object"
            },
            {
              ".ref": "function_object"
            },
            {
              ".ref": "call_object"
            }
          ]
        },
        "point_object": {
          ".all": [
            {
              ".rgx": "\\*([a-z][\\-\\_a-z0-9]*)"
            },
            {
              ".ref": "lookup_indices"
            }
          ]
        },
        "lookup_indices": {
          ".ref": "lookup_index",
          "+min": 0
        },
        "lookup_index": {
          ".rgx": ":([a-zA-Z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|(?:0|\\-?[1-9][0-9]*)|'((?:[^\\n\\\\']|\\\\[\\\\'])*?)'|\"((?:[^\\n\\\\\"]|\\\\[\\\\\"0nt])*?)\"|\\([a-zA-Z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*\\)|\\[[a-zA-Z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*\\])"
        },
        "string_object": {
          ".any": [
            {
              ".ref": "double_string"
            },
            {
              ".ref": "single_string"
            }
          ]
        },
        "double_string": {
          ".rgx": "\"((?:[^\\n\\\\\"]|\\\\[\\\\\"0nt])*?)\""
        },
        "single_string": {
          ".rgx": "'((?:[^\\n\\\\']|\\\\[\\\\'])*?)'"
        },
        "number_object": {
          ".rgx": "(\\-?[0-9]+(?:\\.[0-9]+)?)"
        },
        "regex_object": {
          ".rgx": "/((?:[^\\n\\\\/]|\\\\[\\\\/ntwds\\{\\}\\[\\]\\?\\*\\+])*?)/"
        },
        "list_object": {
          ".all": [
            {
              ".rgx": "\\["
            },
            {
              ".all": [
                {
                  ".ref": "code_object"
                },
                {
                  ".all": [
                    {
                      ".rgx": "[\\ \\t]*,[\\ \\t]*"
                    },
                    {
                      ".ref": "code_object"
                    }
                  ],
                  "+min": 0
                }
              ],
              "+max": 1
            },
            {
              ".rgx": "\\]"
            }
          ]
        },
        "function_object": {
          ".all": [
            {
              ".ref": "function_signature",
              "+max": 1
            },
            {
              ".rgx": "[\\ \\t]*=\\>(?:;(?: (?=\\S))?|\\r?\\n?)"
            },
            {
              ".ref": "indent",
              "-skip": 1
            },
            {
              ".all": [
                {
                  ".ref": "ondent",
                  "-skip": 1
                },
                {
                  ".ref": "code_statement"
                }
              ],
              "+min": 1
            },
            {
              ".ref": "undent",
              "-skip": 1
            },
            {
              ".rgx": "(?=[\\s\\S]|$)"
            }
          ]
        },
        "function_signature": {
          ".all": [
            {
              ".rgx": "\\([\\ \\t]*"
            },
            {
              ".ref": "function_variables"
            },
            {
              ".rgx": "[\\ \\t]*\\)"
            }
          ]
        },
        "function_variables": {
          ".all": [
            {
              ".ref": "function_variable"
            },
            {
              ".all": [
                {
                  ".rgx": ",[\\ \\t]*"
                },
                {
                  ".ref": "function_variable"
                }
              ],
              "+min": 0
            }
          ],
          "+max": 1
        },
        "function_variable": {
          ".rgx": "(\\*?[a-z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|_)"
        },
        "call_object": {
          ".all": [
            {
              ".ref": "call_name"
            },
            {
              ".ref": "call_arguments",
              "+max": 1
            },
            {
              ".ref": "lookup_indices"
            }
          ]
        },
        "call_name": {
          ".rgx": "([a-zA-Z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|_)"
        },
        "call_arguments": {
          ".all": [
            {
              ".ref": "LPAREN"
            },
            {
              ".all": [
                {
                  ".ref": "code_expression"
                },
                {
                  ".all": [
                    {
                      ".rgx": ",[\\ \\t]*"
                    },
                    {
                      ".ref": "code_expression"
                    }
                  ],
                  "+min": 0
                }
              ],
              "+max": 1
            },
            {
              ".ref": "RPAREN"
            }
          ]
        },
        "LPAREN": {
          ".rgx": "\\("
        },
        "RPAREN": {
          ".rgx": "\\)"
        },
        "function_call": {
          ".all": [
            {
              ".ref": "call_operator",
              "-skip": 1
            },
            {
              ".any": [
                {
                  ".ref": "call_object"
                },
                {
                  ".ref": "callable_function_object"
                }
              ]
            }
          ]
        },
        "call_operator": {
          ".ref": "DOT"
        },
        "DOT": {
          ".rgx": "\\."
        },
        "callable_function_object": {
          ".all": [
            {
              ".ref": "function_signature"
            },
            {
              ".rgx": "[\\ \\t]*=\\>(?:;(?: (?=\\S))?|\\r?\\n?)"
            },
            {
              ".ref": "indent",
              "-skip": 1
            },
            {
              ".all": [
                {
                  ".ref": "ondent",
                  "-skip": 1
                },
                {
                  ".ref": "code_statement"
                }
              ],
              "+min": 1
            },
            {
              ".ref": "undent",
              "-skip": 1
            },
            {
              ".rgx": "(?=[\\s\\S]|$)"
            }
          ]
        },
        "each_call": {
          ".all": [
            {
              ".ref": "each_operator",
              "-skip": 1
            },
            {
              ".ref": "code_expression"
            }
          ]
        },
        "each_operator": {
          ".rgx": "[\\ \\t]+%[\\ \\t]+"
        },
        "loop_statement": {
          ".all": [
            {
              ".rgx": "%[\\ \\t]+"
            },
            {
              ".any": [
                {
                  ".ref": "pick_statement"
                },
                {
                  ".ref": "function_statement"
                },
                {
                  ".ref": "expression_statement"
                }
              ]
            }
          ]
        },
        "pick_statement": {
          ".all": [
            {
              ".ref": "pick_expression"
            },
            {
              ".any": [
                {
                  ".ref": "function_statement"
                },
                {
                  ".ref": "expression_statement"
                }
              ]
            }
          ]
        },
        "pick_expression": {
          ".all": [
            {
              ".ref": "LANGLE"
            },
            {
              ".all": [
                {
                  ".ref": "pick_argument"
                },
                {
                  ".all": [
                    {
                      ".rgx": ",[\\ \\t]*"
                    },
                    {
                      ".ref": "pick_argument"
                    }
                  ],
                  "+min": 0
                }
              ]
            },
            {
              ".ref": "RANGLE"
            },
            {
              ".ref": "__"
            }
          ]
        },
        "LANGLE": {
          ".rgx": "<"
        },
        "pick_argument": {
          ".rgx": "(!?\\*[a-z][\\-\\_a-z0-9]*)"
        },
        "RANGLE": {
          ".rgx": ">"
        },
        "function_statement": {
          ".ref": "function_object"
        },
        "expression_statement": {
          ".all": [
            {
              ".ref": "expression_label",
              "+max": 1
            },
            {
              ".ref": "code_expression"
            },
            {
              ".ref": "assertion_expression",
              "+max": 1
            },
            {
              ".ref": "suffix_label",
              "+max": 1
            },
            {
              ".ref": "ending"
            }
          ]
        },
        "expression_label": {
          ".rgx": "\"((?:[^\\n\\\\\"]|\\\\[\\\\\"0nt])*?)\":\\s*"
        },
        "assertion_expression": {
          ".any": [
            {
              ".ref": "assertion_eq"
            },
            {
              ".ref": "assertion_has"
            },
            {
              ".ref": "assertion_like"
            }
          ]
        },
        "assertion_eq": {
          ".all": [
            {
              ".rgx": "[\\ \\t]+(==)[\\ \\t]+"
            },
            {
              ".ref": "code_expression"
            }
          ]
        },
        "assertion_has": {
          ".all": [
            {
              ".rgx": "[\\ \\t]+(\\~\\~)[\\ \\t]+"
            },
            {
              ".ref": "code_expression"
            }
          ]
        },
        "assertion_like": {
          ".all": [
            {
              ".rgx": "[\\ \\t]+(=\\~)[\\ \\t]+"
            },
            {
              ".ref": "code_expression"
            }
          ]
        },
        "suffix_label": {
          ".rgx": "\\s*:\"((?:[^\\n\\\\\"]|\\\\[\\\\\"0nt])*?)\""
        },
        "data_section": {
          ".ref": "block_definition",
          "+min": 0
        },
        "block_definition": {
          ".all": [
            {
              ".ref": "block_heading"
            },
            {
              ".ref": "user_defined"
            },
            {
              ".ref": "point_definition",
              "+min": 0
            }
          ]
        },
        "block_heading": {
          ".rgx": "===(?:[\\ \\t]+(.*?)[\\ \\t]*)?\\r?\\n"
        },
        "user_defined": {
          ".rgx": "((?:.*\\r?\\n)*?(?=\\-\\-\\-|===|$))"
        },
        "point_definition": {
          ".any": [
            {
              ".ref": "point_single"
            },
            {
              ".ref": "point_multi"
            }
          ]
        },
        "point_single": {
          ".rgx": "\\-\\-\\-[\\ \\t]+(\\^?)((?:[a-z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|(?:HEAD|LAST|ONLY|SKIP|TODO|DIFF)))(?:=((?:[a-z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|(?:HEAD|LAST|ONLY|SKIP|TODO|DIFF))))?(?:(\\()([\\#\\+\\-\\~/\\@%]*)\\))?:[\\ \\t]+(.*?[\\ \\t]*)\\r?\\n(?:.*\\r?\\n)*?(?=\\-\\-\\-|===|$)"
        },
        "point_multi": {
          ".rgx": "\\-\\-\\-[\\ \\t]+(\\^?)((?:[a-z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|(?:HEAD|LAST|ONLY|SKIP|TODO|DIFF)))(?:=((?:[a-z][a-zA-Z0-9]*(?:\\-[a-zA-Z][a-zA-Z0-9]*)*|(?:HEAD|LAST|ONLY|SKIP|TODO|DIFF))))?(?:(\\()([<\\#\\+\\-\\~/\\@%]*)\\))?\\r?\\n((?:.*\\r?\\n)*?(?=\\-\\-\\-|===|$))"
        }
      };
    }

  };

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  require('pegex').require('tree');

  TestMLCompiler.AST = class AST extends Pegex.Tree {
    constructor(args = {}) {
      super();
      this.code = [];
      this.data = [];
      this.point = {};
      this.transforms = {};
      ({file: this.file, importer: this.importer} = args);
    }

    final() {
      var ast, got, i, imports, j, k, len, len1, len2, ref, ref1, s, statement;
      got = {
        testml: '0.3.0',
        code: [],
        data: []
      };
      ref = this.code;
      for (i = 0, len = ref.length; i < len; i++) {
        statement = ref[i];
        if (_.isPlainObject(statement)) {
          if (imports = statement.imports) {
            for (j = 0, len1 = imports.length; j < len1; j++) {
              ast = imports[j];
              if (ast.code.length && got.data.length) {
                die("Can't import code after data started");
              }
              got.code.push(...ast.code);
              got.data.push(...ast.data);
            }
          }
        } else {
          if (statement[0] === '<>') {
            statement[0] = '%<>';
          } else if (statement[0] === '=>') {
            ref1 = statement[2];
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              s = ref1[k];
              if (s[0] === '<>') {
                statement = ['%<>', [], statement];
                break;
              }
            }
          }
          got.code.push(statement);
        }
      }
      got.data.push(...(this.make_data(this.data)));
      return got;
    }

    got_code_section(got) {
      this.code = got;
    }

    got_import_directive(got) {
      var i, imports, j, len, len1, more, name, names;
      [[name, more]] = got;
      names = [name];
      for (i = 0, len = more.length; i < len; i++) {
        name = more[i];
        if (name[0] != null) {
          names.push(name[0]);
        }
      }
      imports = [];
      for (j = 0, len1 = names.length; j < len1; j++) {
        name = names[j];
        imports.push(this.importer(name, this.file));
      }
      return {
        imports: imports
      };
    }

    got_assignment_statement(got) {
      var expression, operator, variable;
      [[variable, operator], expression] = got;
      return [operator, variable, expression];
    }

    got_loop_statement(got) {
      var expr, pick;
      expr = got[0];
      pick = expr.pick || {};
      return ['%<>', _.keys(pick), expr];
    }

    got_pick_statement([pick, statement]) {
      return ['<>', pick, statement];
    }

    got_expression_statement(got) {
      var label, left, pick, right, statement, suffix_label;
      if (_.isPlainObject(got[0])) {
        label = got.shift();
      }
      pick = {};
      [left, right, suffix_label] = got;
      if (!suffix_label && _.isPlainObject(right)) {
        suffix_label = right;
        right = null;
      }
      if (right != null) {
        right[1] = left;
        statement = right;
        _.merge(pick, statement[1].pick, statement[2].pick);
      } else {
        statement = left;
      }
      if (label != null) {
        statement.push(label.label);
      } else if (suffix_label != null) {
        statement.push(suffix_label.label);
      }
      pick = _.keys(pick);
      if (pick.length > 0) {
        statement = ['<>', pick, statement];
      }
      return statement;
    }

    got_expression_label(got) {
      return {
        label: got
      };
    }

    got_suffix_label(got) {
      return {
        label: got
      };
    }

    got_pick_expression(got) {
      var i, item, len, more, pick;
      got = got[0];
      pick = {
        [`${got.shift()}`]: true
      };
      more = got[0];
      for (i = 0, len = more.length; i < len; i++) {
        item = more[i];
        if (!item.length) {
          continue;
        }
        pick[item[0]] = true;
      }
      return _.keys(pick);
    }

    got_code_expression(got) {
      var calls, e, each, expr, i, len, object, pick;
      [object, calls, each] = got;
      expr = [object, ...calls];
      pick = {};
      for (i = 0, len = expr.length; i < len; i++) {
        e = expr[i];
        _.merge(pick, e.pick || {});
      }
      if (expr.length === 1) {
        expr = expr[0];
        if (object.callable) {
          expr = ['&', expr];
        }
      } else {
        expr = ['.', ...expr];
      }
      if (each != null) {
        expr = ['%', expr, each];
      }
      if (_.isArray(expr)) {
        expr.pick = pick;
      }
      return expr;
    }

    got_point_object(got) {
      var i, index, indices, len, name, object, opcode;
      [name, indices] = got;
      object = ['*', name];
      indices || (indices = []);
      for (i = 0, len = indices.length; i < len; i++) {
        [opcode, index] = indices[i];
        object = [opcode, object, index];
      }
      object.pick = {
        [`*${name}`]: true
      };
      return object;
    }

    got_double_string(got) {
      var value;
      value = got.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
      if (value.match(/^(?:\\\\|[^\\])*?\{/)) {
        value = ["$''", value];
      }
      return value;
    }

    got_number_object(got) {
      return Number(got);
    }

    got_regex_object(got) {
      return ['/', got];
    }

    got_list_object([got]) {
      var first, i, item, len, list, rest;
      list = [];
      [first, rest] = got;
      rest = _.filter(_.map(rest, function(x) {
        return x[0];
      }));
      if (first != null) {
        list.push(first);
        for (i = 0, len = rest.length; i < len; i++) {
          item = rest[i];
          list.push(item);
        }
      }
      return [list];
    }

    got_function_object(got) {
      var i, item, len, signature;
      signature = got.length === 2 ? got.shift()[0] : [];
      got.unshift('=>', signature);
      got.pick = {};
      for (i = 0, len = signature.length; i < len; i++) {
        item = signature[i];
        if (item.match(/^\*/)) {
          got.pick[item] = true;
        }
      }
      return got;
    }

    got_callable_function_object(got) {
      return this.got_function_object(got);
    }

    got_function_variables(got) {
      var i, item, len, more, vars;
      vars = [got.shift()];
      if (!got.length) {
        return [];
      }
      more = got[0];
      for (i = 0, len = more.length; i < len; i++) {
        item = more[i];
        if (!item.length) {
          continue;
        }
        vars.push(item[0]);
      }
      return vars;
    }

    got_call_object(got) {
      var a, args, callable, i, index, indices, j, len, len1, name, object, opcode;
      [name, args, indices] = got;
      if (args != null ? args.indices : void 0) {
        indices = args;
        args = null;
      }
      callable = (args != null) && args.length === 0;
      args || (args = []);
      indices || (indices = []);
      object = [name, ...args];
      for (i = 0, len = indices.length; i < len; i++) {
        [opcode, index] = indices[i];
        object = [opcode, object, index];
      }
      object.pick = {};
      for (j = 0, len1 = args.length; j < len1; j++) {
        a = args[j];
        _.merge(object.pick, a.pick || {});
      }
      object.callable = callable;
      return object;
    }

    got_lookup_indices(got) {
      var indices;
      indices = _.map(got, (index) => {
        var m, opcode;
        opcode = ':';
        index = (function() {
          switch (false) {
            case !(m = index.match(/^"(.*)"$/)):
              return ["$''", m[1]];
            case !(m = index.match(/^'(.*)'$/)):
              return m[1];
            case !(m = index.match(/^\((.*)\)$/)):
              return [m[1]];
            case !(m = index.match(/^\[(.*)\]$/)):
              opcode = '[]';
              return [m[1]];
            case !(m = index.match(/^-?\d/)):
              opcode = '[]';
              return Number(index);
            default:
              return index;
          }
        })();
        return [opcode, index];
      });
      indices.indices = true;
      return indices;
    }

    got_lookup_index(got) {
      return got[0];
    }

    got_call_arguments(got) {
      var args, i, item, len, more;
      got = got[0];
      args = [got.shift()];
      if (!got.length) {
        return [];
      }
      more = got[0];
      for (i = 0, len = more.length; i < len; i++) {
        item = more[i];
        if (!item.length) {
          continue;
        }
        args.push(item[0]);
      }
      return args;
    }

    got_assertion_expression(got) {
      var expression, operator;
      [operator, expression] = got;
      return [operator, null, expression];
    }

    got_block_definition([label, user, points]) {
      var block, from, has_transforms, i, inherit, len, name, p, point, transforms, value;
      point = {};
      for (i = 0, len = points.length; i < len; i++) {
        p = points[i];
        [inherit, name, from, has_transforms, transforms, value] = p;
        if (name.match(/^(?:HEAD|LAST|ONLY|SKIP|TODO|DIFF)$/)) {
          point[name] = true;
        } else {
          point[name] = this.make_point(name, value, inherit, from, has_transforms, transforms);
        }
      }
      this.data || (this.data = []);
      block = {
        label: label,
        point: point
      };
      if (user.match(/\S/)) {
        block.user = user;
      }
      return this.data.push(block);
    }

    got_point_single(got) {
      var m, value;
      value = got[5];
      if (value.match(/^-?\d+(\.\d+)?$/)) {
        value = Number(value);
      } else if (m = value.match(/^'(.*)'\s*$/)) {
        value = m[1];
      } else if (m = value.match(/^"(.*)"\s*$/)) {
        value = m[1];
      }
      got[5] = value;
      return got;
    }

    got_comment_lines(got) {}

    //------------------------------------------------------------------------------
    make_point(name, value, inherit, from, has_transforms, transform_expr) {
      var CoffeeScript, flag, key, transforms;
      if (!_.isString(value)) {
        return value;
      }
      if (from && !inherit) {
        throw `Can't use '--- ${name}=${from}' without '^' in front`;
      }
      if (inherit) {
        key = from || name;
        value = this.point[key] || '';
        if (!has_transforms) {
          transform_expr = this.transforms[key] || '';
        }
      } else {
        this.point[name] = value;
      }
      transforms = {};
      _.map(_.split(transform_expr, ''), function(f) {
        return transforms[f] = true;
      });
      this.transforms[name] = inherit ? '' : transform_expr;
      if (_.isString(value)) {
        if (!transforms['#']) {
          value = value.replace(/^#.*\n/gm, '');
        }
        value = value.replace(/^\\/gm, '');
        if (!transforms['+'] && value.match(/\n/)) {
          value = value.replace(/\n+$/, '\n');
          if (value === '\n') {
            value = '';
          }
        }
        if (transforms['<']) {
          value = value.replace(/^    /gm, '');
        }
        if (transforms['~']) {
          value = value.replace(/\n+/g, '\n');
        }
        if (transforms['@']) {
          if (value.match(/\n/)) {
            value = value.replace(/\n$/, '').split(/\n/);
          } else {
            value = value.split(/\s+/);
          }
          value = [value];
        } else if (transforms['%']) {
          if (TestMLCompiler.browser) {
            CoffeeScript = window.CoffeeScript;
          } else {
            CoffeeScript = require('coffeescript');
          }
          value = eval(CoffeeScript.compile(value, {
            bare: true
          }));
          if (_.isPlainObject(value) || _.isArray(value)) {
            value = [value];
          }
        } else if (transforms['-']) {
          value = value.replace(/\n$/, '');
        }
      }
      if (transforms['/']) {
        if (_.isArray(value) && _.isArray(value[0])) {
          value = _.map(value[0], function(regex) {
            return ['/', regex];
          });
          value = [value];
        } else {
          flag = value.match(/\n/) ? 'x' : '';
          value = ['/', value.replace(/\n$/, '')];
          if (flag) {
            value.push(flag);
          }
        }
      }
      if (inherit && from) {
        this.point[name] = value;
      }
      return value;
    }

    make_data(data) {
      var block, blocks, i, len;
      blocks = [];
      for (i = 0, len = data.length; i < len; i++) {
        block = data[i];
        if (block.point.SKIP) {
          continue;
        }
        if (block.point.ONLY) {
          return [block];
        }
        if (block.point.HEAD) {
          blocks = [];
        }
        if (block.point.LAST) {
          blocks.push(block);
          return blocks;
        }
        blocks.push(block);
      }
      return blocks;
    }

  };

  // vim: ft=coffee sw=2:

}).call(this);

// Generated by CoffeeScript 2.3.1
(function() {
  var parse_testml;

  require('../testml-compiler');

  require('../testml-compiler/grammar');

  require('../testml-compiler/ast');

  require('pegex').require('parser');

  parse_testml = function(testml_input, testml_file, importer) {
    var parser;
    parser = new Pegex.Parser({
      grammar: new TestMLCompiler.Grammar,
      receiver: new TestMLCompiler.AST({
        file: testml_file,
        importer: importer
      }),
      debug: Boolean(TestMLCompiler.env.TESTML_COMPILER_DEBUG)
    });
    return parser.parse(testml_input);
  };

  TestMLCompiler.Compiler = (function() {
    class Compiler {
      constructor(options = {}) {
        if (options.importer != null) {
          ({importer: this.importer} = options);
        }
      }

      compile(testml_input, testml_file = '-') {
        var grammar;
        if (TestMLCompiler.env.TESTML_COMPILER_GRAMMAR_PRINT) {
          grammar = new TestMLCompiler.DevGrammar;
          grammar.make_tree();
          say(JSON.stringify(grammar.tree, null, 2));
          exit(0);
        }
        if (testml_input.length) {
          testml_input.replace(/\n?$/, '\n');
        }
        return this.ast_to_json(parse_testml(testml_input, testml_file, this.importer));
      }

      importer(name, from) {
        var root, testml_file, testml_input;
        if (from === '-' || !from.match(/\//)) {
          root = '.';
        } else {
          root = from.replace(/^(.*)\/.*/, '$1');
        }
        testml_file = `${root}/${name}.tml`;
        testml_input = file_read(testml_file);
        return parse_testml(testml_input, testml_file, this.importer);
      }

      ast_to_json(ast) {
        var json;
        json = JSON.stringify(ast, null, 2);
        json = json.replace(/\[([^\{\[]+?)\]/g, function(m, m1) {
          return `[${m1.replace(/\n */g, '')}]`;
        });
        json = json.replace(/\ \[\n +"/g, ' ["');
        json = json.replace(/("=>",)\n *(\[[^\n]*\])/g, '$1$2');
        json = json.replace(/("\$''",)\n */g, '$1');
        json = json.replace(/\n *([\}\]])/g, '$1');
        json = json.replace(/^(\ +\["%<>",)\n\ +/mg, '$1');
        json = json.replace(/\ \[\n +\[/g, ' [[');
        json = json.replace(/^(\ +"code": \[)\[/m, '$1\n    [');
        json = json.replace(/(\{)\n +("(?:testml|label)":)/g, '$1 $2');
        json = json.replace(/^(\ +\{)\n\ +\"/mg, '$1 "');
        json = json.replace(/("=",)\n\ */g, '$1');
        return json + "\n";
      }

    };

    Compiler.prototype.ast = null;

    return Compiler;

  }).call(this);

}).call(this);

;

  TestMLCompiler.browser = true;

  window.global = _global;

  window.require = _require;

  window.exports = _exports;

}).call(this);
